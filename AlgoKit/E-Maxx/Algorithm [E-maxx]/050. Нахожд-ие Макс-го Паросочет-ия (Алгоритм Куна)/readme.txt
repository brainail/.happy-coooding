Алгоритм Куна нахождения наибольшего паросочетания в двудольном графе

Дан двудольный граф, содержащий N вершин и M рёбер. Требуется найти наибольшее паросочетание, т.е. выбрать как можно больше рёбер, чтобы ни одно выбранное ребро не имело общей вершины ни с каким другим выбранным ребром.
Описание

Цепью длины k назовём некоторый простой путь (т.е. не содержащий повторяющихся вершин или рёбер), содержащий k рёбер. Чередующейся цепью (в двудольном графе, относительно некоторого паросочетания) назовём цепь, в которой рёбра поочередно принадлежат/не принадлежат паросочетанию. Увеличивающей цепью (в двудольном графе, относительно некоторого паросочетания) назовём цепь, у которой начальная и конечная вершины не принадлежат паросочетанию.

Теорема Бержа. Паросочетание является максимальным тогда и только тогда, когда не существует увеличивающих относительно него цепей.

Далее, заметим, что если найдена некоторая увеличивающая цепь, то с её помощью легко увеличить мощность паросочетания на 1. Пройдём вдоль этой цепи, и каждое ребро поочерёдно будем добавлять/удалять из паросочетания (т.е. первое ребро (которое по определению не принадлежит паросочетанию) добавим в паросочетание, второе удалим, третье добавим, и т.д.). Действительно, в результате этой операции мы увеличим мощность паросочетания на 1 (для этого достаточно заметить, что длина увеличивающей цепи всегда нечётно, а корректность вышеописанного преобразования очевидна).

Таким образом, мы получили каркас алгоритма построения максимального паросочетания: искать в графе увеличивающие цепи, пока они существуют, и увеличивать паросочетание вдоль них.

Осталось детализировать способ нахождения увеличивающих цепей. Алгоритм Куна основан на поиске в глубину или в ширину, и выбирает каждый раз любую из найденных увеличивающих цепей. Стоит заметить, что есть и другие способы, например, в более эффективном алгоритме Хопкрофта-Карпа.

Поскольку каждая увеличивающая цепь будет найдена за O (N+M), а всего цепей понадобится найти не более N/2, то итоговая асимптотика алгоритма равна O (N2 + N M), т.е. O (N M).

Рассмотрим подробнее алгоритм поиска увеличивающей цепи (пусть, для определённости, это поиск в глубину). Поиск начинает идти из вершины первой доли. Из первой доли во вторую он ходит только по рёбрам, не принадлежащим паросочетанию, а из второй доли в первую - наоборот, только по принадлежащим. С точки зрения реализации, поиск в глубину всегда находится в вершине первой доли, и он возвращает булево значение - найдена цепь или не найдена. Из текущей вершины V поиск в глубину пытается пойти по всем смежным рёбрам (кроме принадлежащего паросочетанию), и если он может пойти в вершину To второй доли, не принадлежащей паросочетанию, то возвращает True и добавляет ребро (V,To) в паросочетание. Если же он пытается пойти в вершину To, уже принадлежащую паросочетанию, то он вызывает себя из вершины Mt[To] (соседа To в паросочетании), и если цепь была найдена, то добавляет ребро (V, To) в паросочетание.
Реализация

Здесь N - число вершин в первой доле, K - во второй доле.

int n, k;
vector < vector<int> > g;
vector<int> mt;
vector<char> used;

bool kuhn (int v) {
	if (used[v])  return false;
	used[v] = true;
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (mt[to] == -1 || kuhn (mt[to])) {
			mt[to] = v;
			return true;
		}
	}
	return false;
}

int main() {
	... чтение графа ...

	mt.assign (k, -1);
	for (int i=0; i<n; ++i) {
		used.assign (n, false);
		kuhn (i);
	}

	for (int i=0; i<k; ++i)
		if (mt[i] != -1)
			printf ("%d %d\n", mt[i]+1, i+1);
}

Улучшенная реализация

Модифицируем алгоритм следующим образом. До основного цикла алгоритма найдём каким-нибудь простым алгоритмом произвольное паросочетание (каким-либо жадным алгоритмом), и лишь затем будем выполнять цикл с вызовами функции kuhn(), который будет улучшать это паросочетание. В результате алгоритм будет работать заметно быстрее на случайных графах - потому что в большинстве графов можно легко набрать паросочетание достаточно большого веса.

Например, можно просто перебрать все вершины первой доли, и для каждой из них найти произвольное ребро, которое можно добавить в паросочетание, и добавить его. Даже такая простая эвристика способна ускорить алгоритм Куна в несколько раз.

Следует обратить внимание на то, что основной цикл придётся немного модифицировать. Поскольку при вызове функции kuhn в основном цикле предполагается, что текущая вершина ещё не входит в паросочетание, то нужно добавить соответствующую проверку.

В реализации изменится только код в функции main():

int main() {
	... чтение графа ...

	mt.assign (k, -1);
	vector<char> used1 (n);
	for (int i=0; i<n; ++i)
		for (size_t j=0; j<g[i].size(); ++j)
			if (mt[g[i][j]] == -1) {
				mt[g[i][j]] = i;
				used1[i] = true;
				break;
			}
	for (int i=0; i<n; ++i) {
		if (used1[i])  continue;
		used.assign (n, false);
		kuhn (i);
	}

	for (int i=0; i<k; ++i)
		if (mt[i] != -1)
			printf ("%d %d\n", mt[i]+1, i+1);
}

Другой хорошей эвристикой является следующая. На каждом шаге будет искать вершину наименьшей степени (но не изолированную), из неё выбирать любое (?) ребро и добавлять его в паросочетание, затем удаляя обе эти вершины со всеми инцидентными им рёбрами из графа. Такая жадность работает очень хорошо на случайных графах, даже в большинстве случаев строит максимальное паросочетание, однако на специально подобранном тесте она может найти паросочетание значительно меньшей величины, чем максимальное.